"""
Image Visualization Script

This script visualizes images from multiple sources:
1. Original images from the dataset
2. Images generated by the HuggingFace model (with and without CFG)
3. Images generated by the fine-tuned model (with and without CFG)

Display modes:
- Triplet mode:
  - With guidance_scale=None: Shows (Original, HF without CFG, FT without CFG)
  - With guidance_scale specified: Shows (Original, HF with CFG, FT with CFG)
- Quintuplet mode (requires guidance_scale):
  - Shows (Original, HF without CFG, FT without CFG, HF with CFG, FT with CFG)
  - Falls back to triplet if guidance_scale is None

Usage:
    python visualize_images_and_captions.py --num_images 5 [--seed 42] [--split test|validation|train]
                                           [--guidance_scale 7.5] [--display_mode triplet|quintuplet]
"""

import os
import json
import random
import argparse
import matplotlib.pyplot as plt
from PIL import Image
import numpy as np
from paths import DATASET_PATH
from tqdm import tqdm


def load_captions(caption_file):
    """
    Load captions from a JSON file.

    Args:
        caption_file: Path to the JSON file containing captions

    Returns:
        Dictionary of captions keyed by image ID
    """
    with open(caption_file, "r") as f:
        captions = json.load(f)
    print(f"Loaded {len(captions)} captions from {caption_file}")
    return captions


def find_original_image(img_id, dataset_path):
    """
    Find the original image in any of the dataset splits (test, validation, train).

    Args:
        img_id: Image ID to search for
        dataset_path: Base path to the dataset

    Returns:
        Path to the original image or None if not found
    """
    splits = ["test", "validation", "train", "restval"]

    for split in splits:
        img_path = os.path.join(
            dataset_path, "images", split, f"{int(img_id):012d}.jpg"
        )
        if os.path.exists(img_path):
            return img_path

    return None


def plot_image_triplet(img_id, caption, paths, output_dir, size, guidance_scale=None):
    """
    Plot a triplet of images (original + generated images) with the caption.

    Args:
        img_id: Image ID
        caption: Caption for the images
        paths: Dictionary containing paths to the images
        output_dir: Directory to save the plot
        size: Size of the images
        guidance_scale: Guidance scale for the CFG images

    Returns:
        Path to the saved plot or None if the plot couldn't be created
    """
    try:
        # Determine which keys to use based on whether we're using CFG or not
        hf_key = "hf" if guidance_scale is None else "hf_cfg"
        ft_key = "ft" if guidance_scale is None else "ft_cfg"
        required_keys = ["original", hf_key, ft_key]

        # Check if all required images exist
        for key in required_keys:
            if key not in paths or not paths[key]:
                print(f"Skipping triplet for image {img_id} - Missing: {key}")
                return None
            if not os.path.exists(paths[key]):
                print(
                    f"Skipping triplet for image {img_id} - {key} file not found at: {paths[key]}"
                )
                return None

        fig, axes = plt.subplots(1, 3, figsize=(15, 5))

        # Set the super title (caption)
        plt.suptitle(caption, fontsize=12, wrap=True)

        # Plot original image
        img = Image.open(paths["original"]).convert("RGB")
        axes[0].imshow(np.array(img))
        axes[0].set_title("Original Image")

        # Plot HF generated image
        img = Image.open(paths[hf_key]).convert("RGB")
        axes[1].imshow(np.array(img))
        axes[1].set_title(
            "HF Generated" + (f" (CFG={guidance_scale:.1f})" if guidance_scale else "")
        )

        # Plot FT generated image
        img = Image.open(paths[ft_key]).convert("RGB")
        axes[2].imshow(np.array(img))
        axes[2].set_title(
            "FT Generated" + (f" (CFG={guidance_scale:.1f})" if guidance_scale else "")
        )

        # Remove axis ticks
        for ax in axes:
            ax.set_xticks([])
            ax.set_yticks([])

        # Adjust layout to minimize white space
        plt.tight_layout()
        plt.subplots_adjust(top=0.85)  # Adjust top to make room for the caption

        # Save the plot
        os.makedirs(output_dir, exist_ok=True)

        # Create filename based on mode
        output_path = os.path.join(
            output_dir,
            f"triplet_{size}_"
            + (f"cfg{guidance_scale:.1f}_" if guidance_scale else "")
            + f"_{int(img_id):012d}.png",
        )
        plt.savefig(output_path, bbox_inches="tight")
        plt.close()

        return output_path

    except Exception as e:
        print(f"Error processing triplet for image {img_id}: {str(e)}")
        # Clean up if the figure was created but there was an error
        plt.close()
        return None


def plot_image_quintuplet(img_id, caption, paths, output_dir, size, guidance_scale):
    """
    Plot a quintuplet of images (original, HF without CFG, FT without CFG, HF with CFG, FT with CFG) with the caption.

    Args:
        img_id: Image ID
        caption: Caption for the images
        paths: Dictionary containing paths to the five images
        output_dir: Directory to save the plot
        size: Size of the images
        guidance_scale: Guidance scale used for CFG images

    Returns:
        Path to the saved plot or None if the plot couldn't be created
    """
    try:
        # Check if all required images exist
        required_keys = ["original", "hf", "ft", "hf_cfg", "ft_cfg"]

        # Check if all required keys are in the paths dictionary
        for key in required_keys:
            if key not in paths or not paths[key]:
                print(f"Skipping quintuplet for image {img_id} - Missing: {key}")
                return None
            if not os.path.exists(paths[key]):
                print(
                    f"Skipping quintuplet for image {img_id} - {key} file not found at: {paths[key]}"
                )
                return None

        fig, axes = plt.subplots(1, 5, figsize=(20, 5))

        # Set the super title (caption)
        plt.suptitle(caption, fontsize=12, wrap=True)

        # Plot original image
        img = Image.open(paths["original"]).convert("RGB")
        axes[0].imshow(np.array(img))
        axes[0].set_title("Original Image")

        # Plot HF generated image (no CFG)
        img = Image.open(paths["hf"]).convert("RGB")
        axes[1].imshow(np.array(img))
        axes[1].set_title("HF Generated (no CFG)")

        # Plot FT generated image (no CFG)
        img = Image.open(paths["ft"]).convert("RGB")
        axes[2].imshow(np.array(img))
        axes[2].set_title("FT Generated (no CFG)")

        # Plot HF generated image with CFG
        img = Image.open(paths["hf_cfg"]).convert("RGB")
        axes[3].imshow(np.array(img))
        axes[3].set_title(f"HF Generated (CFG={guidance_scale:.1f})")

        # Plot FT generated image with CFG
        img = Image.open(paths["ft_cfg"]).convert("RGB")
        axes[4].imshow(np.array(img))
        axes[4].set_title(f"FT Generated (CFG={guidance_scale:.1f})")

        # Remove axis ticks
        for ax in axes:
            ax.set_xticks([])
            ax.set_yticks([])

        # Adjust layout to minimize white space
        plt.tight_layout()
        plt.subplots_adjust(top=0.85)  # Adjust top to make room for the caption

        # Save the plot
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(
            output_dir,
            f"quintuplet_{size}_cfg{guidance_scale:.1f}_{int(img_id):012d}.png",
        )
        plt.savefig(output_path, bbox_inches="tight")
        plt.close()

        return output_path

    except Exception as e:
        print(f"Error processing quintuplet for image {img_id}: {str(e)}")
        # Clean up if the figure was created but there was an error
        plt.close()
        return None


def get_image_paths(img_id, script_dir, dataset_path, size, guidance_scale=None):
    """
    Get all possible image paths for a given image ID.

    Args:
        img_id: Image ID
        script_dir: Script directory
        dataset_path: Dataset path
        size: Image size
        guidance_scale: Guidance scale (if any)

    Returns:
        Dictionary of image paths
    """
    paths = {"original": find_original_image(img_id, dataset_path)}

    # Add standard (non-CFG) image paths
    hf_gen_dir = os.path.join(script_dir, f"../generated_images_hf_{size}")
    ft_gen_dir = os.path.join(script_dir, f"../generated_images_ft_{size}")

    hf_file = f"{int(img_id):012d}.png"
    ft_file = f"{int(img_id):012d}.png"

    hf_path = os.path.join(hf_gen_dir, hf_file)
    ft_path = os.path.join(ft_gen_dir, ft_file)

    paths["hf"] = hf_path if os.path.exists(hf_path) else None
    paths["ft"] = ft_path if os.path.exists(ft_path) else None

    # Add CFG image paths if guidance_scale is provided
    if guidance_scale is not None:
        hf_cfg_dir = os.path.join(
            script_dir, f"../generated_images_hf_{size}_cfg{guidance_scale:.1f}"
        )
        ft_cfg_dir = os.path.join(
            script_dir, f"../generated_images_ft_{size}_cfg{guidance_scale:.1f}"
        )

        hf_cfg_path = os.path.join(hf_cfg_dir, hf_file)
        ft_cfg_path = os.path.join(ft_cfg_dir, ft_file)

        paths["hf_cfg"] = hf_cfg_path if os.path.exists(hf_cfg_path) else None
        paths["ft_cfg"] = ft_cfg_path if os.path.exists(ft_cfg_path) else None

    return paths


def find_caption_file(script_dir, size, guidance_scale=None):
    """
    Find an appropriate caption file based on configuration.

    Args:
        script_dir: Script directory
        size: Image size
        guidance_scale: Guidance scale if any

    Returns:
        Path to caption file or None if not found
    """
    # Try finding caption file in CFG directory first if guidance_scale is provided
    if guidance_scale is not None:
        cfg_dir = os.path.join(
            script_dir, f"../generated_images_hf_{size}_cfg{guidance_scale:.1f}"
        )
        cfg_caption = os.path.join(cfg_dir, "caption_mapping_merged.json")
        if os.path.exists(cfg_caption):
            return cfg_caption

    # Fallback to standard directory
    std_dir = os.path.join(script_dir, f"../generated_images_hf_{size}")
    std_caption = os.path.join(std_dir, "caption_mapping_merged.json")
    if os.path.exists(std_caption):
        return std_caption

    return None


def main(args):
    """
    Main function to run the visualization.

    Args:
        args: Command line arguments
    """
    # Set random seed for reproducibility
    random.seed(args.seed)

    # Determine the script directory
    script_dir = os.path.dirname(os.path.abspath(__file__))
    plots_dir = os.path.join(script_dir, "../plots")

    # Find appropriate caption file
    caption_file = find_caption_file(script_dir, args.size, args.guidance_scale)

    if not caption_file:
        print("No caption file found in expected locations.")
        return

    # Load captions
    captions = load_captions(caption_file)

    # Select random sample of image IDs
    img_ids = list(captions.keys())
    if args.num_images > len(img_ids):
        print(
            f"Requested {args.num_images} images but only {len(img_ids)} are available. Using all available images."
        )
        args.num_images = len(img_ids)

    selected_ids = random.sample(img_ids, args.num_images)
    print(f"Selected {len(selected_ids)} random images")

    # Track successfully processed images
    successful_triplets = 0
    successful_triplets_cfg = 0
    successful_quintuplets = 0

    # Process each selected image
    for img_id in tqdm(selected_ids):
        caption = captions[img_id]

        # Get all possible image paths
        paths = get_image_paths(
            img_id, script_dir, DATASET_PATH, args.size, args.guidance_scale
        )

        # Handle display mode based on guidance_scale and user preference
        output_path = None

        # CASE 1: Quintuplet mode with guidance_scale
        if args.display_mode == "quintuplet" and args.guidance_scale is not None:
            # Check if we have all required images for quintuplet
            if all(
                key in paths and paths[key]
                for key in ["original", "hf", "ft", "hf_cfg", "ft_cfg"]
            ):
                output_path = plot_image_quintuplet(
                    img_id, caption, paths, plots_dir, args.size, args.guidance_scale
                )
                if output_path:
                    successful_quintuplets += 1
            else:
                print(
                    f"Cannot create quintuplet for image {img_id} - missing required images."
                )

        # CASE 2: Quintuplet mode without guidance_scale (falls back to triplet)
        elif args.display_mode == "quintuplet" and args.guidance_scale is None:
            print(
                f"Quintuplet mode requires guidance_scale. Falling back to standard triplet for image {img_id}."
            )
            if all(key in paths and paths[key] for key in ["original", "hf", "ft"]):
                output_path = plot_image_triplet(
                    img_id, caption, paths, plots_dir, args.size, guidance_scale=None
                )
                if output_path:
                    successful_triplets += 1
            else:
                print(
                    f"Cannot create triplet for image {img_id} - missing required images."
                )

        # CASE 3: Triplet mode with guidance_scale (use CFG images)
        elif args.display_mode == "triplet" and args.guidance_scale is not None:
            if all(
                key in paths and paths[key] for key in ["original", "hf_cfg", "ft_cfg"]
            ):
                output_path = plot_image_triplet(
                    img_id,
                    caption,
                    paths,
                    plots_dir,
                    args.size,
                    guidance_scale=args.guidance_scale,
                )
                if output_path:
                    successful_triplets_cfg += 1
            else:
                print(
                    f"Cannot create CFG triplet for image {img_id} - missing required images."
                )

        # CASE 4: Triplet mode without guidance_scale (use standard images)
        else:  # args.display_mode == "triplet" and args.guidance_scale is None
            if all(key in paths and paths[key] for key in ["original", "hf", "ft"]):
                output_path = plot_image_triplet(
                    img_id, caption, paths, plots_dir, args.size, guidance_scale=None
                )
                if output_path:
                    successful_triplets += 1
            else:
                print(
                    f"Cannot create standard triplet for image {img_id} - missing required images."
                )

        if output_path:
            print(f"Saved plot: {output_path}")

    # Print summary
    print("\n===== Summary =====")
    if successful_triplets > 0:
        print(f"Successfully created {successful_triplets} standard triplet plots")
    if successful_triplets_cfg > 0:
        print(f"Successfully created {successful_triplets_cfg} CFG triplet plots")
    if successful_quintuplets > 0:
        print(f"Successfully created {successful_quintuplets} quintuplet plots")

    total_successful = (
        successful_triplets + successful_triplets_cfg + successful_quintuplets
    )
    print(
        f"Total processed: {total_successful} out of {len(selected_ids)} selected images"
    )


def parse_args():
    """
    Parse command line arguments.

    Returns:
        Parsed arguments
    """
    parser = argparse.ArgumentParser(
        description="Visualize original and generated images with captions"
    )
    parser.add_argument("--num_images", type=int, default=5)
    parser.add_argument("--seed", type=int, default=42)
    parser.add_argument("--size", type=int, default=512)
    parser.add_argument("--split", type=str, default="test")
    parser.add_argument("--guidance_scale", type=float, default=None)
    parser.add_argument(
        "--display_mode",
        type=str,
        choices=["triplet", "quintuplet"],
        default="triplet",
        help="Display mode: triplet or quintuplet (requires guidance_scale)",
    )
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    main(args)
